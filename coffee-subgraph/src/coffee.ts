import { BigInt } from "@graphprotocol/graph-ts"
import {
  coffee,
  OwnershipTransferred,
  newFarm,
  newForeman,
  workerCheckedIn,
  workerPaid
} from "../generated/coffee/coffee"
import { Worker, Farm, Foreman, Payment, CheckIn } from "../generated/schema"


export function handleOwnershipTransferred(event: OwnershipTransferred): void {
  // Don't need to store owner in theGraph
}

export function handlenewFarm(event: newFarm): void {
  let newFarm = new Farm(event.params.farmAddress);
  newFarm.save();
}

export function handlenewForeman(event: newForeman): void {
  let newForeman = new Foreman(event.params.foreman);
  // sets to the farm who created the foreman
  newForeman.hasFarm = event.transaction.from;
  newForeman.save();
}

export function handleworkerCheckedIn(event: workerCheckedIn): void {
  /*╔═════════════════════════════╗
    ║       UPDATE WORKER         ║
    ╚═════════════════════════════╝*/

  let worker = Worker.load(event.params.worker);

  // if the worker doesn't exist, create one
  if(!worker){
    worker = new Worker(event.params.worker);
    // being checked in means they worked one day
    worker.daysWorked = 1;
    // They haven't been paid yet since they get checked in before
    // they get paid.
    worker.daysUnpaid = 1;
  }
  else {
    // if the worker exists, increment days worked 
    // and days unpaid by 1.
    worker.daysWorked += 1;
    worker.daysUnpaid += 1;
  }

  worker.save();


  /*╔═════════════════════════════╗
    ║       UPDATE FOREMAN        ║
    ╚═════════════════════════════╝*/
  let foreman = Foreman.load(event.params.foreman);
  // A checkin cannot exist without a foreman because coffee.sol
  // checkIn() function is only callable by a foreman, but
  // the subgraph doesn't know that so we have to have this check.
  if(!foreman) {
    foreman = new Foreman(event.params.foreman);
  }
  // If the array of associated workers for a foreman doesn't
  // already include this worker, add this worker to the array.
  // '?' means possibly null
  if(!foreman.hasWorkers?.includes(worker.id)){
    foreman.hasWorkers?.push(worker.id);
  }
  foreman.save();


  /*╔═════════════════════════════╗
    ║       UPDATE CHECKIN        ║
    ╚═════════════════════════════╝*/
  // Create new checkin and sets the ID to transaction hash since hashes are unique
  let checkin = new CheckIn(event.transaction.hash);
  checkin.farmCheckedInAt = foreman.hasFarm;
  checkin.foremanWhoChecked = foreman.id;
  checkin.workerCheckedIn = worker.id;
  checkin.save();
}

export function handleworkerPaid(event: workerPaid): void {
  /*╔═════════════════════════════╗
    ║       UPDATE WORKER         ║
    ╚═════════════════════════════╝*/
  let worker = Worker.load(event.params.worker); 
  // We are assuming that a worker will never be paid before being
  // checked in.
  if(!worker){
    worker = new Worker(event.params.worker);
  }
  // Worker is now paid for all their previous days unpaid
  let oldDaysUnpaid = worker.daysUnpaid;
  worker.daysUnpaid = 0;
  worker.save();

  /*╔═════════════════════════════╗
    ║       UPDATE PAYMENT        ║
    ╚═════════════════════════════╝*/
  
  let payment = new Payment(event.transaction.hash);
  payment.amount = event.params.amount;
  payment.daysPaidFor = oldDaysUnpaid;
  // I'm assuming we can do it this way instead of loading in
  // the farm (which takes time).
  payment.farmWhoPaid = event.params.farm;
  payment.workerPaid = worker.id;
  payment.save();
}

  /*╔══════════════════════════════════════════════════════════╗
    ║       BELOW ARE JUST NOTES GENERATED BY THEGRAPH         ║
    ╚══════════════════════════════════════════════════════════╝*/
  
  // Entities can be loaded from the store using a string ID; this ID
  // needs to be unique across all entities of the same type
  // let entity = ExampleEntity.load(event.transaction.from.toHex())

  // Entities only exist after they have been saved to the store;
  // `null` checks allow to create entities on demand
  // if (!entity) {
  //   entity = new ExampleEntity(event.transaction.from.toHex())

    // Entity fields can be set using simple assignments
  //   entity.count = BigInt.fromI32(0)
  //}

  // BigInt and BigDecimal math are supported
  // entity.count = entity.count + BigInt.fromI32(1)

  // Entity fields can be set based on event parameters
  //entity.previousOwner = event.params.previousOwner
  //entity.newOwner = event.params.newOwner

  // Entities can be written to the store with `.save()`
  //entity.save()

  // Note: If a handler doesn't require existing field values, it is faster
  // _not_ to load the entity from the store. Instead, create it fresh with
  // `new Entity(...)`, set the fields that should be updated and save the
  // entity back to the store. Fields that were not set or unset remain
  // unchanged, allowing for partial updates to be applied.

  // It is also possible to access smart contracts from mappings. For
  // example, the contract that has emitted the event can be connected to
  // with:
  //
  // let contract = Contract.bind(event.address)
  //
  // The following functions can then be called on this contract to access
  // state variables and other data:
  //
  // - contract.isFarm(...)
  // - contract.isForeman(...)
  // - contract.owner(...)
